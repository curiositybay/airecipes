import { NextRequest } from 'next/server';

// Mock the app config
jest.mock('@/config/app', () => ({
  appConfig: {
    authServiceUrl: 'http://auth-service.example.com',
  },
}));

// Mock fetch globally
global.fetch = jest.fn();

// Set required environment variable
process.env.AUTH_SERVICE_URL = 'http://auth-service.example.com';

// Import after mocking
import { verifyAuth, requireAuth, loginAsDemoUser } from './auth';

describe('auth.ts', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('verifyAuth', () => {
    let mockRequest: NextRequest;

    beforeEach(() => {
      mockRequest = {
        cookies: {
          get: jest.fn(),
        },
        headers: {
          get: jest.fn(),
        },
      } as unknown as NextRequest;
    });

    it('should return error when no auth token is provided', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue(undefined);
      (mockRequest.headers.get as jest.Mock).mockReturnValue(undefined);

      const result = await verifyAuth(mockRequest);

      expect(result).toEqual({
        success: false,
        error: 'No authentication token provided',
      });
    });

    it('should use auth token from cookies', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue({ value: 'cookie-token' });
      (mockRequest.headers.get as jest.Mock).mockReturnValue(undefined);

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          success: true,
          user: {
            id: 'user-123',
            email: 'test@example.com',
            role: 'read-only',
            app_name: 'airecipes',
          },
        }),
      });

      const result = await verifyAuth(mockRequest);

      expect(global.fetch).toHaveBeenCalledWith(
        'http://auth-service.example.com/api/v1/auth/verify',
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: 'Bearer cookie-token',
          },
          body: JSON.stringify({ app_name: 'airecipes' }),
        }
      );

      expect(result).toEqual({
        success: true,
        user: {
          id: 'user-123',
          email: 'test@example.com',
          role: 'read-only',
          app_name: 'airecipes',
        },
      });
    });

    it('should use auth token from Authorization header', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue(undefined);
      (mockRequest.headers.get as jest.Mock).mockReturnValue('Bearer header-token');

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          success: true,
          user: {
            id: 'user-123',
            email: 'test@example.com',
            role: 'read-only',
            app_name: 'airecipes',
          },
        }),
      });

      const result = await verifyAuth(mockRequest);

      expect(global.fetch).toHaveBeenCalledWith(
        'http://auth-service.example.com/api/v1/auth/verify',
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: 'Bearer header-token',
          },
          body: JSON.stringify({ app_name: 'airecipes' }),
        }
      );

      expect(result.success).toBe(true);
    });

    it('should prioritize cookies over Authorization header', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue({ value: 'cookie-token' });
      (mockRequest.headers.get as jest.Mock).mockReturnValue('Bearer header-token');

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          success: true,
          user: {
            id: 'user-123',
            email: 'test@example.com',
            role: 'read-only',
            app_name: 'airecipes',
          },
        }),
      });

      await verifyAuth(mockRequest);

      expect(global.fetch).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: 'Bearer cookie-token',
          }),
        })
      );
    });

    it('should handle auth service error response', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue({ value: 'valid-token' });

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 401,
      });

      const result = await verifyAuth(mockRequest);

      expect(result).toEqual({
        success: false,
        error: 'Invalid or expired authentication token',
      });
    });

    it('should handle auth service response without success', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue({ value: 'valid-token' });

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          success: false,
          error: 'Token expired',
        }),
      });

      const result = await verifyAuth(mockRequest);

      expect(result).toEqual({
        success: false,
        error: 'Authentication verification failed',
      });
    });

    it('should handle auth service response without user data', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue({ value: 'valid-token' });

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          success: true,
          // No user data
        }),
      });

      const result = await verifyAuth(mockRequest);

      expect(result).toEqual({
        success: false,
        error: 'Authentication verification failed',
      });
    });

    it('should handle network errors', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue({ value: 'valid-token' });

      (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

      const result = await verifyAuth(mockRequest);

      expect(result).toEqual({
        success: false,
        error: 'Authentication service unavailable',
      });
    });

    it('should handle JSON parsing errors', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue({ value: 'valid-token' });

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockRejectedValue(new Error('Invalid JSON')),
      });

      const result = await verifyAuth(mockRequest);

      expect(result).toEqual({
        success: false,
        error: 'Authentication service unavailable',
      });
    });
  });

  describe('requireAuth', () => {
    let mockRequest: NextRequest;

    beforeEach(() => {
      mockRequest = {
        cookies: {
          get: jest.fn(),
        },
        headers: {
          get: jest.fn(),
        },
      } as unknown as NextRequest;
    });

    it('should return auth result when verification succeeds', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue({ value: 'valid-token' });

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          success: true,
          user: {
            id: 'user-123',
            email: 'test@example.com',
            role: 'read-only',
            app_name: 'airecipes',
          },
        }),
      });

      const result = await requireAuth(mockRequest);

      expect(result).toEqual({
        success: true,
        user: {
          id: 'user-123',
          email: 'test@example.com',
          role: 'read-only',
          app_name: 'airecipes',
        },
      });
    });

    it('should throw error when verification fails', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue(undefined);
      (mockRequest.headers.get as jest.Mock).mockReturnValue(undefined);

      await expect(requireAuth(mockRequest)).rejects.toThrow('No authentication token provided');
    });

    it('should throw error with custom message when verification fails', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue({ value: 'invalid-token' });

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 401,
      });

      await expect(requireAuth(mockRequest)).rejects.toThrow('Invalid or expired authentication token');
    });

    it('should throw generic error when verification fails without error message', async () => {
      (mockRequest.cookies.get as jest.Mock).mockReturnValue({ value: 'invalid-token' });

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          success: false,
          // No error message
        }),
      });

      await expect(requireAuth(mockRequest)).rejects.toThrow('Authentication required');
    });
  });

  describe('loginAsDemoUser', () => {
    it('should successfully login demo user', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          success: true,
          user: {
            id: 'demo-123',
            email: 'demo@example.com',
            role: 'read-only',
            app_name: 'airecipes',
          },
        }),
      });

      const result = await loginAsDemoUser();

      expect(global.fetch).toHaveBeenCalledWith(
        'http://auth-service.example.com/api/v1/auth/login',
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({
            email: 'demo@example.com',
            password: 'demo123',
            app_name: 'airecipes',
          }),
        }
      );

      expect(result).toEqual({
        success: true,
        user: {
          id: 'demo-123',
          email: 'demo@example.com',
          role: 'read-only',
          app_name: 'airecipes',
        },
      });
    });

    it('should handle login failure response', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 401,
      });

      const result = await loginAsDemoUser();

      expect(result).toEqual({
        success: false,
        error: 'Demo login failed',
      });
    });

    it('should handle login response without success', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          success: false,
          error: 'Invalid credentials',
        }),
      });

      const result = await loginAsDemoUser();

      expect(result).toEqual({
        success: false,
        error: 'Demo login failed',
      });
    });

    it('should handle login response without user data', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          success: true,
          // No user data
        }),
      });

      const result = await loginAsDemoUser();

      expect(result).toEqual({
        success: false,
        error: 'Demo login failed',
      });
    });

    it('should handle network errors during login', async () => {
      (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

      const result = await loginAsDemoUser();

      expect(result).toEqual({
        success: false,
        error: 'Demo login failed',
      });
    });

    it('should handle JSON parsing errors during login', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockRejectedValue(new Error('Invalid JSON')),
      });

      const result = await loginAsDemoUser();

      expect(result).toEqual({
        success: false,
        error: 'Demo login failed',
      });
    });
  });
}); 